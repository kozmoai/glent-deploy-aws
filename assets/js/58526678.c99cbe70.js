"use strict";(self.webpackChunk_aws_glent_on_aws_website=self.webpackChunk_aws_glent_on_aws_website||[]).push([[6216],{6901:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var n=t(4848),i=t(8453);const r={sidebar_position:4},a="Cluster Access",o={id:"techdocs/runtimes/kubernetes/clusterAccess",title:"Cluster Access",description:'In order to provision and perform operations on kubernetes environments and applications, GLENT needs kubernetes RBAC permissions. GLENT accomplishes this by first assuming an IAM role and then retrieving a kubernetes token based on that role. EKS enables the mechanism of mapping an IAM role to kubernetes RBAC permissions. The mapping between an IAM role and a kubernetes principal is configured in the "aws-auth" ConfigMap in the kube-system namespace.',source:"@site/docs/techdocs/runtimes/kubernetes/clusterAccess.md",sourceDirName:"techdocs/runtimes/kubernetes",slug:"/techdocs/runtimes/kubernetes/clusterAccess",permalink:"/docs/techdocs/runtimes/kubernetes/clusterAccess",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Kubernetes Applications",permalink:"/docs/techdocs/runtimes/kubernetes/k8sApps"},next:{title:"Security",permalink:"/docs/techdocs/security"}},c={},l=[{value:"2 Levels of Access",id:"2-levels-of-access",level:2},{value:"User Access To The Kubernetes API",id:"user-access-to-the-kubernetes-api",level:2}];function u(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"cluster-access",children:"Cluster Access"}),"\n",(0,n.jsx)(s.p,{children:'In order to provision and perform operations on kubernetes environments and applications, GLENT needs kubernetes RBAC permissions. GLENT accomplishes this by first assuming an IAM role and then retrieving a kubernetes token based on that role. EKS enables the mechanism of mapping an IAM role to kubernetes RBAC permissions. The mapping between an IAM role and a kubernetes principal is configured in the "aws-auth" ConfigMap in the kube-system namespace.'}),"\n",(0,n.jsx)(s.h2,{id:"2-levels-of-access",children:"2 Levels of Access"}),"\n",(0,n.jsx)(s.p,{children:"GLENT makes use of 2 different levels of access when it talks to the kubernetes API server. The first level has cluster-wide administrator access and the second has admin access that is limited to a specific kubernetes namespace."}),"\n",(0,n.jsx)(s.p,{children:"GLENT uses the cluster-wide admin privileges in these scenarios:"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsx)(s.li,{children:"Provisioning environment providers"}),"\n",(0,n.jsx)(s.li,{children:"Application CICD pipelines"}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"When you create a new environment provider, GLENT will ask you what IAM role you want to use for cluster administration. If you do not provide an existing role, GLENT will create one for you. This IAM role is mapped to have full administrative privileges to execute any kubernetes API calls."}),"\n",(0,n.jsx)(s.p,{children:"GLENT uses namespace-limited administrative access to perform lookups and operations on applications. For example, when a developer selects an application in the GLENT UI, all reads and writes to Kubernetes that are performed by GLENT to support this UI are done using an IAM role that can only see and update kubernetes resources that are assigned to that namespace."}),"\n",(0,n.jsx)(s.p,{children:"The IAM role that is granted namespace-limited access is determined when a developer sets up an application to run on an GLENT environment. GLENT will accept an existing IAM role to be provided or it can create the namespace-limited role if desired. It then takes care of updating the aws-auth ConfigMap so that the IAM role is associated with the right kubernetes principal."}),"\n",(0,n.jsx)(s.h2,{id:"user-access-to-the-kubernetes-api",children:"User Access To The Kubernetes API"}),"\n",(0,n.jsx)(s.p,{children:"Users typically interact with the kubernetes API server using kubectl. GLENT does not prevent using kubectl in any way. Users can continue to get a kubectl session the same way as they always did."}),"\n",(0,n.jsx)(s.p,{children:"GLENT does allow for one more interesting possibility - it is possible to allow human beings to use the same permissions that GLENT does. To enable this, administrators can grant access for users to assume the same AWS IAM role(s) that GLENT does. Once they are logged into AWS with a cluster admin or namespace-limited admin role, they can exchange their IAM principal for a token that will allow them to use kubectl."}),"\n",(0,n.jsxs)(s.p,{children:["As prerequisites, users will need to have kubectl and the ",(0,n.jsx)(s.a,{href:"https://aws.amazon.com/cli/",children:"AWS CLI"})," installed on their machines. Once this is done, they can configure kubectl to talk to their EKS cluster using the following command. Make sure you fill in a real value for the region and cluster name."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{children:"aws eks update-kubeconfig --region <my-cluster-region> --name <my-cluster-name>\n"})}),"\n",(0,n.jsx)(s.p,{children:"Another valuable way that GLENT IAM roles can be used by humans is for accessing the AWS Web console. By logging into the console as an GLENT IAM role, users would be able to go to the EKS service and view their cluster. EKS provides a dashboard that shows many configurations and allows users to see what resources are deployed to their cluster. If users log in with a cluster admin role, they can see everything in the cluster, but if they log in with a namespace-limited role, they will only be able to see the cluster resources that are contained in that namespace."})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>o});var n=t(6540);const i={},r=n.createContext(i);function a(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);